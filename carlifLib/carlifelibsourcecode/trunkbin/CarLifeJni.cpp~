/*******************************************************
	Author: 
		Liu Caiquan
	Date: 
		@17th-June-2016@

	CarLife Protocol version:
		@V1.0.12@
							Copyright (C) Under BaiDu, Inc.
*******************************************************/
#include"CCarLifeLibWrapper.h"
#include "CarLifeLibTest.h"
#include<pthread.h>
#include<unistd.h>
#include <jni.h>
#include <utils/Log.h>

/****************************************
FUNCTIONS
*****************************************/
void *cmdReceiveThread(void *arg);
void *videoReceiveThread(void *arg);
void *mediaReceiveThread(void *arg);
void *ttsReceiveThread(void *arg);
void *vrReceiveThread(void *arg);

void cmdProtocolVersionMatchStatus(S_PROTOCOL_VERSION_MATCH_SATUS* status);
void cmdMDInfro(S_MD_INFO*);
void cmdMDBTPairInfro(BTPairInfo*);
void cmdVideoEncoderInitDone(S_VIDEO_ENCODER_INIT_DONE*);
void cmdVideoEncoderFrameRateChangeDone(S_VIDEO_ENCODER_FRAME_RATE_CHANGE_DONE*);
void cmdTelStateChangeIncoming();
void cmdTelStateChangeOutGoing();
void cmdTelStateChangeIdle();
void cmdTelStateChangeInCalling();
void cmdScreenOn();
void cmdScreenOff();
void cmdScreenUserPresent();
void cmdForeground();
void cmdBackground();
void cmdGoToDeskTop();
void cmdMicRecordWakeupStart();
void cmdMicRecordEnd();
void cmdMicRecordRecogStart();
//0x00010026
void cmdModuleStatus(S_MODULE_STATUS_LIST_MOBILE*);
//0x00010030
void cmdNaviNextTurnInfo(S_NAVI_NEXT_TURN_INFO*);
//0x00010031
void cmdCarDataSubscribe(S_VEHICLE_INFO_LIST*);	
//0x00010033
void cmdCarDataSubscribeStart(S_VEHICLE_INFO_LIST*);
//0x00010034
void cmdCarDataSubscribeStop(S_VEHICLE_INFO_LIST*);
//0x00010035
void cmdMediaInfo(S_MEDIA_INFO*);
//0x00010036
void cmdMediaProgressBar(S_MEDIA_PROGRESS_BAR*);
//0x00010037
void cmdRegisterConnectException(S_CONNECTION_EXCEPTION*);
//0x00010038
void cmdRegisterRequestGoToForeground(void);
//0x00010039
void cmdRegisterUIActionSound(void);

//0x00010049
void cmdRegisterMdAuthenResponse(S_AUTHEN_RESPONSE* response);

//0x00010051
void cmdRegisterFeatureConfigRequest();

void videoDataReceive(u8 *data, u32 len);
void videoHeartBeat();
void mediaInit(S_AUDIO_INIT_PARAMETER *initParam);
void mediaNormalData(u8 *data, u32 len);
void mediaStop();
void mediaPause();
void mediaResume();
void mediaSeek();
void ttsInit(S_AUDIO_INIT_PARAMETER *initParam);
void ttsNormalData(u8 *data, u32 len);
void ttsStop();
void vrInit(S_AUDIO_INIT_PARAMETER *initParam);
void vrNormalData(u8 *data, u32 len);
void vrStop();

/******************************************
INIT PARAMETER
*******************************************/
S_HU_PROTOCOL_VERSION huProtocolVersion={1,0};

S_VIDEO_ENCODER_INIT initVideoParam={768, 480,30};

u8 vrData[1024]={1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9};

S_TOUCH_ACTION touchAction={1, 12 ,34};

S_TOUCH_CAR_HARD_KEY_CODE touchCarHardKeyCode={0x00000010};//next song

//anthorization
S_AUTHEN_REQUEST authenRequest={"CarLife_1.0.0"};

S_FEATURE_CONFIG_LIST configList;
S_FEATURE_CONFIG featureConfigFocusUI;

void setFocusUIConfig(int val){
	configList.cnt=1;
	configList.pFeatureConfig=&featureConfigFocusUI;
	featureConfigFocusUI.key="FOCUS_UI";
	featureConfigFocusUI.value=val;
	featureConfigFocusUI.pNext=NULL;
}

//connection pattern setting
#define ADB_CONNECTION 0
#define IOS_WIFI_CONNECTION 1
#define CONNECTION_PATTERN ADB_CONNECTION

//carlifestate: 1 start; 0 stop
static int carlifestate = 1;
JNIEnv *g_env = NULL;
JNIEnv *env = NULL;  
static JavaVM* jvm = NULL;
void* reserved = NULL; 
static int satus = 1;

//click event
S_TOUCH_ACTION_DOWN TouchActionDown={0,0};
S_TOUCH_ACTION_UP TouchActionUp={0,0};
S_TOUCH_ACTION_MOVE TouchActionMove={0,0};
S_TOUCH_SIGNAL_CLICK TouchSingleClick={0,0};
S_TOUCH_DOUBLE_CLICK TouchDoubleClick={0,0};
S_TOUCH_LONG_PRESS TouchLongPress={0,0};

int nfcarlifetest(){
	int ret;
	pthread_t id;
	int item;

	cout<<"CarLife library test"<<endl;

	cout<<"CarLifeLib initialization && connection set up test:"<<endl;
	//initialize CarLife libaray
	CCarLifeLib::getInstance()->carLifeLibInit();

	//set up connection between head unit and mobile device


	//support ADB connection
	if(CONNECTION_PATTERN==ADB_CONNECTION){
		if(0==CCarLifeLib::getInstance()->connectionSetup()){
			cout<<"command/video/media/tts/vr/control channel connection have been set up!"<<endl;
		}else{
				cout<<"connection set up failed!"<<endl;
		}
	}
	
	ret=pthread_create(&id, NULL, cmdReceiveThread, NULL);
	if(ret!=0){
		cout<<"cmdReceiveThread create failed!"<<endl;
	}else{
	cout<<"cmdReceiveThread create!"<<endl;
	}

	ret=pthread_create(&id, NULL, videoReceiveThread, NULL);
	if(ret!=0){
		cout<<"videoReceivThread create failed!"<<endl;
	}else{
	cout<<"videoReceivThread create !"<<endl;
	}

	ret=pthread_create(&id, NULL, mediaReceiveThread, NULL);
	if(ret!=0){
		cout<<"mediaReceivThread create failed!"<<endl;
	}else{
	cout<<"mediaReceivThread create !"<<endl;
	}

	ret=pthread_create(&id, NULL, ttsReceiveThread, NULL);
	if(ret!=0){
		cout<<"ttsReceivThread create failed!"<<endl;
	}else{
	cout<<"ttsReceivThread create !"<<endl;
	}

	ret=pthread_create(&id, NULL, vrReceiveThread, NULL);
	if(ret!=0){
		cout<<"vrReceivThread create failed!"<<endl;
	}else{
	cout<<"vrReceivThread create !"<<endl;
	}

	cout<<"CarLifeLib test item: "<<endl;
	cout<<"\t1. command channel test;"<<endl;
	cout<<"\t2. video channel test;"<<endl;
	cout<<"\t3. media channel test;"<<endl;
	cout<<"\t4. tts channel test;"<<endl;
	cout<<"\t5. vr channel test;"<<endl;
	cout<<"\t6. control channel test;"<<endl;
	item = 1;

	switch(item){
		case 1:
			//head unit send protocol version information to mobile device
			CCarLifeLib::getInstance()->cmdHUProtoclVersion(&huProtocolVersion);

			//0x00018048 
			//CCarLifeLib::getInstance()->cmdHuAuthenRequest(&authenRequest);

			//setFocusUIConfig(1);
			//0x00018052
			//CCarLifeLib::getInstance()->cmdFeatureConfigResponse(&configList);
			break;
		case 2:
			CCarLifeLib::getInstance()->cmdHUProtoclVersion(&huProtocolVersion);
			
			CCarLifeLib::getInstance()->cmdVideoEncoderInit(&initVideoParam);
			setVideoFormat(initVideoParam.width,initVideoParam.height);
			sleep(2);//sleep 2s
			CCarLifeLib::getInstance()->cmdVideoEncoderStart();
			break;
		case 3:
			CCarLifeLib::getInstance()->cmdHUProtoclVersion(&huProtocolVersion);
			//receive media data
			break;
		case 4:
			CCarLifeLib::getInstance()->cmdHUProtoclVersion(&huProtocolVersion);
			//receive tts data
			break;
		case 5:
			CCarLifeLib::getInstance()->cmdHUProtoclVersion(&huProtocolVersion);
			CCarLifeLib::getInstance()->sendVRRecordData(vrData, 1024, 0);
			break;
		case 6:
			//CCarLifeLib::getInstance()->ctrlTouchAction(&touchAction);
			//CCarLifeLib::getInstance()->ctrlTouchCarHardKeyCode(0x0000000F);//previous song
			CCarLifeLib::getInstance()->ctrlTouchCarHardKeyCode(&touchCarHardKeyCode);//next song
			break;
		default:
			break;
	}
	
	while(1){
		sleep(1);
	}

	//release CarLifeVehicleLib resources
	CCarLifeLib *pCCarLifeLib=CCarLifeLib::getInstance();
	pCCarLifeLib->carLifeLibDestory();
	
	return 0;
}


void *cmdReceiveThread(void *arg){
	//register call back
	CCarLifeLib::getInstance()->cmdRegisterProtocolVersionMatchStatus(cmdProtocolVersionMatchStatus);
	CCarLifeLib::getInstance()->cmdRegisterMDInfro(cmdMDInfro);
	CCarLifeLib::getInstance()->cmdRegisterMDBTPairInfro(cmdMDBTPairInfro);
	CCarLifeLib::getInstance()->cmdRegisterVideoEncoderInitDone(cmdVideoEncoderInitDone);
	CCarLifeLib::getInstance()->cmdRegisterVideoEncoderFrameRateChangeDone(cmdVideoEncoderFrameRateChangeDone);
	CCarLifeLib::getInstance()->cmdRegisterTelStateChangeIncoming(cmdTelStateChangeIncoming);
	CCarLifeLib::getInstance()->cmdRegisterTelStateChangeOutGoing(cmdTelStateChangeOutGoing);
	CCarLifeLib::getInstance()->cmdRegisterTelStateChangeIdle(cmdTelStateChangeIdle);
	CCarLifeLib::getInstance()->cmdRegisterTelStateChangeInCalling(cmdTelStateChangeInCalling);
	CCarLifeLib::getInstance()->cmdRegisterScreenOn(cmdScreenOn);
	CCarLifeLib::getInstance()->cmdRegisterScreenOff(cmdScreenOff);
	CCarLifeLib::getInstance()->cmdRegisterScreenUserPresent(cmdScreenUserPresent);
	CCarLifeLib::getInstance()->cmdRegisterForeground(cmdForeground);
	CCarLifeLib::getInstance()->cmdRegisterBackground(cmdBackground);
	CCarLifeLib::getInstance()->cmdRegisterGoToDeskTop(cmdGoToDeskTop);
	CCarLifeLib::getInstance()->cmdRegisterMicRecordWakeupStart(cmdMicRecordWakeupStart);
	CCarLifeLib::getInstance()->cmdRegisterMicRecordEnd(cmdMicRecordEnd);
	CCarLifeLib::getInstance()->cmdRegisterMicRecordRecogStart(cmdMicRecordRecogStart);
	//0x00010026
	CCarLifeLib::getInstance()->cmdRegisterModuleStatus(cmdModuleStatus);
	//0x00010030
	CCarLifeLib::getInstance()->cmdRegisterNaviNextTurnInfo(cmdNaviNextTurnInfo);
	//0x00010031
	CCarLifeLib::getInstance()->cmdRegisterCarDataSubscribe(cmdCarDataSubscribe);	
	//0x00010033
	CCarLifeLib::getInstance()->cmdRegisterCarDataSubscribeStart(cmdCarDataSubscribeStart);
	//0x00010034
	CCarLifeLib::getInstance()->cmdRegisterCarDataSubscribeStop(cmdCarDataSubscribeStop);
	//0x00010035
	CCarLifeLib::getInstance()->cmdRegisterMediaInfo(cmdMediaInfo);
	//0x00010036
	CCarLifeLib::getInstance()->cmdRegisterMediaProgressBar(cmdMediaProgressBar);
	//0x00010037
	CCarLifeLib::getInstance()->cmdRegisterConnectException(cmdRegisterConnectException);
	//0x00010038
	CCarLifeLib::getInstance()->cmdRegisterRequestGoToForeground(cmdRegisterRequestGoToForeground);
	//0x00010039
	CCarLifeLib::getInstance()->cmdRegisterUIActionSound(cmdRegisterUIActionSound);

	//0x00010049 
	CCarLifeLib::getInstance()->cmdRegisterMdAuthenResponse(cmdRegisterMdAuthenResponse);

	//0x00010051
	CCarLifeLib::getInstance()->cmdRegisterFeatureConfigRequest(cmdRegisterFeatureConfigRequest);


	while(1){
		//receive data from command channel
		if(-1==CCarLifeLib::getInstance()->cmdReceiveOperation()){

			cout<<"command channel receive thread exit!"<<endl;
				
			break;
			}
	}
	return NULL;
}

void *videoReceiveThread(void *arg){
	CCarLifeLib::getInstance()->videoRegisterDataReceive(videoDataReceive);
	CCarLifeLib::getInstance()->videoRegisterHeartBeat(videoHeartBeat);

	while(1){
		if(-1==CCarLifeLib::getInstance()->videoReceiveOperation()){
			cout<<"video channel receive thread exit!"<<endl;
			break;
		}
	}
	return NULL;
}

void *mediaReceiveThread(void *arg){
	CCarLifeLib::getInstance()->mediaRegisterInit(mediaInit);
	CCarLifeLib::getInstance()->mediaRegisterNormalData(mediaNormalData);
	CCarLifeLib::getInstance()->mediaRegisterStop(mediaStop);
	CCarLifeLib::getInstance()->mediaRegisterPause(mediaPause);
	CCarLifeLib::getInstance()->mediaRegisterResume(mediaResume);
	CCarLifeLib::getInstance()->mediaRegisterSeek(mediaSeek);

	while(1){
		if(-1==CCarLifeLib::getInstance()->mediaReceiveOperation()){
			cout<<"media channel thread exit!"<<endl;
			break;
		}
	}
	return NULL;
}

void *ttsReceiveThread(void *arg){
	CCarLifeLib::getInstance()->ttsRegisterInit(ttsInit);
	CCarLifeLib::getInstance()->ttsRegisterNormalData(ttsNormalData);
	CCarLifeLib::getInstance()->ttsRegisterStop(ttsStop);

	while(1){
		if(-1==CCarLifeLib::getInstance()->ttsReceiveOperation()){
			cout<<"tts channel thread exit!"<<endl;
			break;
		}
	}
	return NULL;
}

void *vrReceiveThread(void *arg){
	CCarLifeLib::getInstance()->vrRegisterInit(vrInit);
	CCarLifeLib::getInstance()->vrRegisterNormalData(vrNormalData);
	CCarLifeLib::getInstance()->vrRegisterStop(vrStop);

	while(1){
		if(-1==CCarLifeLib::getInstance()->vrReceiveOperation()){
			cout<<"vr channel thread exit!"<<endl;
			break;
		}
	}
	return NULL;
}

int ClickDownEvent(int x,int y){
	TouchActionDown.x = x;
	TouchActionDown.y = y;
	int i = CCarLifeLib::getInstance()->ctrlTouchActionDown(&TouchActionDown);
	return i;
}

int ClickUpEvent(int x,int y){
	TouchActionUp.x = x;
	TouchActionUp.y = y;
	int i = CCarLifeLib::getInstance()->ctrlTouchActionUp(&TouchActionUp);	
	return i;
} 
	
int OnClickEvent(int x,int y){
	TouchSingleClick.x = x;
	TouchSingleClick.y = y;
	int i = CCarLifeLib::getInstance()->ctrlTouchSigleClick(&TouchSingleClick);
	return i;
}	

		
int DoubleClickEvent(int x,int y){
	TouchDoubleClick.x = x;
	TouchDoubleClick.y = y;
	int i = CCarLifeLib::getInstance()->ctrlTouchDoubleClick(&TouchDoubleClick);
	return i;
}

int HoldOnEvent(int x,int y){
	TouchLongPress.x = x;
	TouchLongPress.y = y;
	int i = CCarLifeLib::getInstance()->ctrlTouchLongPress(&TouchLongPress);
	return i;
}

int MoveEvnet(int x,int y){
	TouchActionMove.x = x;
	TouchActionMove.y = y;
	int i = CCarLifeLib::getInstance()->ctrlTouchActionMove(&
	TouchActionMove);
	return i;
} 		


void setVideoFormat(int width,int height)
{

	JNIEnv *env;

	//get env from g_JavaVM
	g_JavaVM->AttachCurrentThread(&env,NULL);
	ALOGD("setvideoformat get env success");
	
	//get class
	jclass javaClass = env->GetObjectClass(g_obj);
	if(javaClass == NULL)
	{
		ALOGD("setvideoformat fail to find javaClass");
		return; 
	}
	ALOGD("setvideoformat get javaClass success");
	
	
	jmethodID javaCallback = env->GetMethodID(javaClass,"setVideoFormat","(II)V");
	if(javaCallback == NULL)
	{
		ALOGD("setvideoformat fail to find method nativeCallback");
		return; 
	}
	ALOGD("setvideoformat get javaCallback success");
	

	env->CallVoidMethod(g_obj,javaCallback,width,height);	
	
	
}


//video channel callback functions
void videoDataReceive(u8 *data, u32 len){

 	ALOGD("videoDataReceive 000000000000000000000000000000000000000000000");
	JNIEnv *env;

	//get env from g_JavaVM
	g_JavaVM->AttachCurrentThread(&env,NULL);
	ALOGD("get env success");
	
	//get class
	jclass javaClass = env->GetObjectClass(g_obj);
	if(javaClass == NULL)
	{
		ALOGD("fail to find javaClass");
		return; 
	}
	ALOGD("get javaClass success");
	
	
	jmethodID javaCallback = env->GetMethodID(javaClass,"getVideo","([BI)V");
	if(javaCallback == NULL)
	{
		ALOGD("videoDataReceive fail to find method nativeCallback");
		return; 
	}
	ALOGD("get javaCallback success");
	

      jbyteArray array = env->NewByteArray(len);
   jbyte *pArray ;  
   jbyte *ppArray ; 
   
     if(array == NULL){  
        ALOGD("receive_callback: NewCharArray error.");  
        return;   
    }  
  
    pArray = (jbyte*)calloc(len, sizeof(jbyte));
    if(pArray == NULL){  
        ALOGD("receive_callback: calloc error.");  
        return;   
    }  
	ppArray = pArray;

	
    env->SetByteArrayRegion(array,0,len,(jbyte*)data); 
	
	env->CallVoidMethod(g_obj,javaCallback,array,len); 
	ALOGD("callVoidMethod had been cell get()");
	
	
 	env->DeleteLocalRef(array);  
    free(pArray);  
    pArray = NULL;   
	// env->DeleteGlobalRef(g_obj);
	 env->DeleteLocalRef(javaClass);  
	 
	
}

//command channel callback functions
void cmdProtocolVersionMatchStatus(S_PROTOCOL_VERSION_MATCH_SATUS* status){
	cout<<"cmdProtocolVersionMatchStatus() is invoked"<<endl;
	cout<<"\tprotocol version match status: "<<status->matchStatus<<endl;
}

void cmdMDInfro(S_MD_INFO* mdInfro){
	cout<<"cmdMDInfro() is invoked"<<endl;
	cout<<"\tos: "<<mdInfro->os<<endl;
	cout<<"\tboard: "<<mdInfro->board<<endl;
	cout<<"\tbootloader: "<<mdInfro->bootloader<<endl;
	cout<<"\tbrand: "<<mdInfro->brand<<endl;
	cout<<"\tcpu_abi: "<<mdInfro->cpu_abi<<endl;
	cout<<"\tcpu_abi2: "<<mdInfro->cpu_abi2<<endl;
	cout<<"\tdevice: "<<mdInfro->device<<endl;
	cout<<"\tdisplay: "<<mdInfro->display<<endl;
	cout<<"\tfingerprint: "<<mdInfro->fingerprint<<endl;
	cout<<"\thardware: "<<mdInfro->hardware<<endl;
	cout<<"\thost: "<<mdInfro->host<<endl;
	cout<<"\tcid: "<<mdInfro->cid<<endl;
	cout<<"\tmanufacturer: "<<mdInfro->manufacturer<<endl;
	cout<<"\tmodel: "<<mdInfro->model<<endl;
	cout<<"\tproduct: "<<mdInfro->product<<endl;
	cout<<"\tserial: "<<mdInfro->serial<<endl;
	cout<<"\tcodename: "<<mdInfro->codename<<endl;
	cout<<"\tincremental: "<<mdInfro->incremental<<endl;
	cout<<"\trelease: "<<mdInfro->release<<endl;
	cout<<"\tsdk: "<<mdInfro->sdk<<endl;
	cout<<"\tsdk_int: "<<mdInfro->sdk_int<<endl;
	
}

void cmdMDBTPairInfro(BTPairInfo* info){
	cout<<"cmdMDBTPairInfro() is invoked"<<endl;
	cout<<"/taddress: "<<info->address<<endl;
	cout<<"/tpassKey: "<<info->passKey<<endl;
	cout<<"/thash: "<<info->hash<<endl;
	cout<<"/trandomizer: "<<info->randomizer<<endl;
	cout<<"/tuuid: "<<info->uuid<<endl;
	cout<<"/tname: "<<info->name<<endl;
	cout<<"/tstatus: "<<info->status<<endl;
}

void cmdVideoEncoderInitDone(S_VIDEO_ENCODER_INIT_DONE* videoEncoderInitDone){
	cout<<"cmdVideoEncoderInitDone() is invoked"<<endl;
	cout<<"\twidth: "<<videoEncoderInitDone->width<<endl;
	cout<<"\theight: "<<videoEncoderInitDone->height<<endl;
	cout<<"\tframeRate: "<<videoEncoderInitDone->frameRate<<endl;
}

void cmdVideoEncoderFrameRateChangeDone(S_VIDEO_ENCODER_FRAME_RATE_CHANGE_DONE* videoEncoderFrameRateChangeDone){
	cout<<"cmdVideoEncoderFrameRateChangeDone() is invoked"<<endl;
	cout<<"\tframeRate: "<<videoEncoderFrameRateChangeDone->frameRate<<endl;
}

void cmdTelStateChangeIncoming(){
	cout<<"cmdTelStateChangeIncoming() is invoked"<<endl;
}

void cmdTelStateChangeOutGoing(){
	cout<<"cmdTelStateChangeOutGoing() is invoked"<<endl;
}

void cmdTelStateChangeIdle(){
	cout<<"cmdTelStateChangeIdle() is invoked"<<endl;
}
void cmdTelStateChangeInCalling(){
	cout<<"cmdTelStateChangeInCalling() is invoked"<<endl;
}

void cmdScreenOn(){
	cout<<"cmdScreenOn() is invoked"<<endl;
}
void cmdScreenOff(){
	cout<<"cmdScreenOff() is invoked"<<endl;
}
void cmdScreenUserPresent(){
	cout<<"cmdScreenUserPresent() is invoked"<<endl;
}

void cmdForeground(){
	cout<<"cmdForeground() is invoked"<<endl;
}

void cmdBackground(){
	cout<<"cmdBackground() is invoked"<<endl;
}

void cmdGoToDeskTop(){
	cout<<"cmdGoToDeskTop() is invoked"<<endl;
}

void cmdMicRecordWakeupStart(){
	cout<<"cmdMicRecordWakeupStart() is invoked"<<endl;
}
void cmdMicRecordEnd(){
	cout<<"cmdMicRecordEnd() is invoked"<<endl;
}

void cmdMicRecordRecogStart(){
	cout<<"cmdMicRecordRecogStart() is invoked"<<endl;
}

//0x00010026
void cmdModuleStatus(S_MODULE_STATUS_LIST_MOBILE*){
	cout<<"cmdModuleStatus is invoked"<<endl;
}

//0x00010030
void cmdNaviNextTurnInfo(S_NAVI_NEXT_TURN_INFO*){
	cout<<"cmdNaviNextTurnInfo is invoked"<<endl;
}

//0x00010031
void cmdCarDataSubscribe(S_VEHICLE_INFO_LIST*){
	cout<<"cmdCarDataSubscribe is invoked"<<endl;
}

//0x00010033
void cmdCarDataSubscribeStart(S_VEHICLE_INFO_LIST*){	
	cout<<"cmdCarDataSubscribeStart is invoked"<<endl;
}

//0x00010034
void cmdCarDataSubscribeStop(S_VEHICLE_INFO_LIST*){
	cout<<"cmdCarDataSubscribeStop is invoked"<<endl;
}

//0x00010035
void cmdMediaInfo(S_MEDIA_INFO* info){
	cout<<"cmdMediaInfo is invoked"<<endl;
	
	cout<<"source= "<<info->source<<endl;
	cout<<"song= "<<info->song<<endl;
	cout<<"artist= "<<info->artist<<endl;
	cout<<"album= "<<info->album<<endl;
	//cout<<"albumArt= "<<info->albumArt<<endl;
	cout<<"duration= "<<info->duration<<endl;
	cout<<"playlistNum= "<<info->playlistNum<<endl;
	cout<<"songId= "<<info->songId<<endl;
	cout<<"mode= "<<info->mode<<endl;
	
	
}

//0x00010036
void cmdMediaProgressBar(S_MEDIA_PROGRESS_BAR*){
	cout<<"cmdMediaProgressBar is invoked"<<endl;
}

//0x00010037
void cmdRegisterConnectException(S_CONNECTION_EXCEPTION*){
	cout<<"cmdRegisterConnectException is invoked"<<endl;
}

//0x00010038
void cmdRegisterRequestGoToForeground(void){
	cout<<"cmdRegisterRequestGoToForeground is invoked"<<endl;
}

//0x00010039
void cmdRegisterUIActionSound(void){
	cout<<"cmdRegisterUIActionSound is invoked"<<endl;
}

//0x00010049
void cmdRegisterMdAuthenResponse(S_AUTHEN_RESPONSE* response){
	cout<<"cmdRegisterMdAuthenResponse is invoked"<<endl;
	cout<<"encryptValue= "<<response->encryptValue<<endl;
}

//0x00010051
void cmdRegisterFeatureConfigRequest(){
	cout<<"cmdRegisterFeatureConfigRequest is invoked"<<endl;

	setFocusUIConfig(1);
	//0x00018052
	CCarLifeLib::getInstance()->cmdFeatureConfigResponse(&configList);
}


void videoHeartBeat(){
	cout<<"videoHeartBeat() is invoked"<<endl;
	cout<<"\tvideo heart beat received!";
}

//media channel callback functions
void mediaInit(S_AUDIO_INIT_PARAMETER *initParam){
	cout<<"mediaInit() is invoked"<<endl;
	cout<<"\tsampleRate: "<<initParam->sampleRate<<endl;
	cout<<"\tchannelConfig: "<<initParam->channelConfig<<endl;
	cout<<"\tsampleFormat: "<<initParam->sampleFormat<<endl;
}

void mediaNormalData(u8 *data, u32 len){
	cout<<"mediaNormalData() is invoked"<<endl;
	cout<<"\treceive media data: "<<len<<" bytes"<<endl;

}

void mediaStop(){
	cout<<"mediaStop() is invoked"<<endl;
	cout<<"\tmedia stop status received!"<<endl;
}

void mediaPause(){
	cout<<"mediaPause() is invoked"<<endl;
	cout<<" \tmedia pause status received!"<<endl;
}

void mediaResume(){
	cout<<"mediaResume() is invoked"<<endl;
	cout<<"\tmedia resume status received!"<<endl;
}

void mediaSeek(){
	cout<<"mediaSeek() is invoked"<<endl;
	cout<<"\tmedia seek status received!"<<endl;
}

//tts channel callback functions
void ttsInit(S_AUDIO_INIT_PARAMETER *initParam){
	cout<<"ttsInit() is invoked"<<endl;
	cout<<"\tsampleRate: "<<initParam->sampleRate<<endl;
	cout<<"\tchannelConfig: "<<initParam->channelConfig<<endl;
	cout<<"\tsampleFormat: "<<initParam->sampleFormat<<endl;
}

void ttsNormalData(u8 *data, u32 len){
	cout<<"ttsNormalData() is invoked"<<endl;
	cout<<"\treceive tts data: "<<len<<" bytes"<<endl;

	for(int i=0;i<len;i++){
		cout<<data[i]<<" ";
	}

	cout<<endl;

}

void ttsStop(){
	cout<<"ttsStop() is invoked"<<endl;
	cout<<"\ttts stop status received!"<<endl;
}


//vr channel callback functions
void vrInit(S_AUDIO_INIT_PARAMETER *initParam){
	cout<<"vrInit() is invoked"<<endl;
	cout<<"\tsampleRate: "<<initParam->sampleRate<<endl;
	cout<<"\tchannelConfig: "<<initParam->channelConfig<<endl;
	cout<<"\tsampleFormat: "<<initParam->sampleFormat<<endl;
}

void vrNormalData(u8 *data, u32 len){
	cout<<"vrNormalData() is invoked"<<endl;
	cout<<"\treceive vr data: "<<len<<" bytes"<<endl;
/*	
	for(int i=0;i<len;i++){
		cout<<data[i]<<" ";
	}

	cout<<endl;
*/
}

void vrStop(){
	cout<<"vrStop() is invoked"<<endl;
	cout<<"\tvr stop status received!"<<endl;
}







